Инструкция FROM
В инструкции FROM определяется базовый слой для нового образа. Базовым слоем служит готовый образ — как правило, его загружают с Docker Hub.

FROM <image>:<tag>
# <image> — имя базового образа, например, python.
# <tag> — необязательный параметр, указывает конкретную версию образа.
 

 Инструкция WORKDIR
В образе выстраивается собственная структура директорий и файлов; при сборке образа требуется выполнять операции в разных директориях. 
Инструкция WORKDIR позволяет переходить из директории в директорию образа и устанавливает, в какой директории будут выполняться команды, описанные в Dockerfile, — это сходно с выполнением команды cd в терминале.
Инструкций WORKDIR внутри Dockerfile может быть несколько — можно последовательно переходить по директориям и выполнять в них необходимые операции.

WORKDIR <путь-к-директории-внутри-контейнера>
# Тут можно совершить какие-то действия в директории — 
# например, выполнить команду в терминале:
RUN mkdir new_folder
# Потом можно перейти в другую директорию:
WORKDIR <путь-к-другой-директории-внутри-контейнера>
# ...и выполнить какие-то действия в ней. 

Если директории, указанной в инструкции WORKDIR, не существует, эта директория будет создана.
В WORKDIR можно указывать относительный путь, он будет начинаться с текущей директории:

# Это абсолютный путь, он начинается со слеша 
# и отсчитывается от корневой директории:
WORKDIR /workdir 
# Это относительный путь — он без слеша в начале и отсчитывается от той директории,
# в которой мы сейчас:
WORKDIR project
WORKDIR app
RUN pwd 
# Команда pwd выведет адрес /workdir/project/app 
В инструкции WORKDIR лучше указывать абсолютный путь до директории — иначе можно случайно назначить рабочей директорией неизвестную подпапку:

WORKDIR /workdir
WORKDIR /project
WORKDIR /app
RUN pwd
# Выведет адрес директории /app в корне контейнера. 


Если директории, указанной в инструкции WORKDIR, не существует, эта директория будет создана.
В WORKDIR можно указывать относительный путь, он будет начинаться с текущей директории:

# Это абсолютный путь, он начинается со слеша 
# и отсчитывается от корневой директории:
WORKDIR /workdir 
# Это относительный путь — он без слеша в начале и отсчитывается от той директории,
# в которой мы сейчас:
WORKDIR project
WORKDIR app
RUN pwd 
# Команда pwd выведет адрес /workdir/project/app 
В инструкции WORKDIR лучше указывать абсолютный путь до директории — иначе можно случайно назначить рабочей директорией неизвестную подпапку:

WORKDIR /workdir
WORKDIR /project
WORKDIR /app
RUN pwd
# Выведет адрес директории /app в корне контейнера. 

Если целевой директории для копирования не существует — инструкция COPY создаст её.

# Скопировать всё содержимое директории, где хранится Dockerfile,
# в директорию /nonexistent образа.
COPY . /nonexistent
# Если в образе не было директории /nonexistent, она будет создана.

Файл .dockerignore
Некоторые файлы и директории не должны попасть в образ: они там не нужны, при копировании надо исключить их. Такие исключения можно перечислить в файле .dockerignore; он должен располагаться в той же директории, что и Dockerfile. Принцип работы файла .dockerignore такой же, как у .gitignore.
В качестве примера можно привести файлы виртуального окружения и файлы Git-репозитория. Их много, из-за них замедляется сборка образа — но эти файлы никак не используются в образе, это просто балласт, который увеличит вес образа. Так что с чистой совестью добавляем директории venv и .git в .dockerignore:

# Файл .dockerignore
venv
.git
db.sqlite3 


Инструкция RUN
Эта инструкция выполняет команды терминала внутри образа так, как если бы эти команды выполнял разработчик. 

RUN <команда> 
Инструкцией RUN можно вызвать утилиту, можно создать директорию через mkdir — можно выполнить любую команду, которую обычно вызывают через терминал. Чтобы инструкция сработала, к моменту выполнения команды образ уже должен содержать вызываемую утилиту.
В докерфайле для Taski инструкция RUN запускает внутри образа команду для установки зависимостей:

# Если не использовать параметр --no-cache-dir, 
# то pip сохранит в служебной директории (прямо в образе) копии пакетов,
# а это будет лишним грузом.
RUN pip install -r /app/requirements.txt --no-cache-dir

Инструкция CMD
Мало запустить контейнер — нужно запустить и приложение внутри контейнера. 
Инструкция CMD указывает, какую команду нужно выполнить при запуске контейнера, — в отличие от инструкции RUN, которая выполнит команду при сборке образа.
У инструкции CMD есть три особенности:
в Dockerfile срабатывает только одна инструкция CMD. Если этих инструкций несколько, выполнится только та, что записана последней;
параметры инструкции CMD указываются в виде JSON-массива, элементы массива заключаются в двойные кавычки;
первым элементом указывается исполняемый файл, например, интерпретатор Python; следом указываются параметры для запуска исполняемого файла:

CMD ["исполняемый_файл", "аргумент_1", ..., "аргумент_2"] 
Инструкция CMD в вашем Dockerfile запустит веб-сервер разработки Django-приложения внутри контейнера:

CMD ["python", "manage.py", "runserver", "0:8000"] 


Создадим и настроим внешнее хранилище для базы данных проекта Taski. План действий таков:
Создать Docker volume с названием sqlite_data.
Настроить проект Taski так, чтобы файл db.sqlite3 хранился в отдельной папке, которую можно привязать к созданному volume.
Запустить контейнер бэкенда и при старте указать связь volume sqlite_data с той папкой в контейнере, где хранится db.sqlite3.
Применить миграции в контейнере; в файле базы данных будут созданы таблицы.
Проверить, что изменения сохранились в файле за пределами контейнера: открыть файл базы данных на хосте и убедиться, что там созданы таблицы.
Создайте Docker volume:

docker volume create sqlite_data 

# запуск с примотированием volume
docker run --name taski_backend_container -p 8000:8000 -v sqlite_data:/data taski_backend


# Создать образ (build); 
# присвоить образу имя и тег (-t); 
# Dockerfile взять в указанной директории.
docker build -t username/taski_backend:latest backend/
docker build -t username/taski_frontend:latest frontend/ 

Загрузка образов на Docker Hub
Прежде чем загружать образы на Docker Hub, нужно аутентифицировать там докер-демон. Выполните команду аутентификации:

docker login
# А можно сразу указать имя пользователя:
docker login -u username 

После авторизации можно запушить образы на Docker Hub:

docker push username/taski_backend:latest
docker push username/taski_frontend:latest 

Чтобы изменить образ, загруженный на Docker Hub, нужно локально внести изменения в код проекта или докерфайл,
 пересобрать образ и выполнить команду docker push <imagename>: образ обновится на Docker Hub.
Пользователь, скачавший образ, может обновить его на локальном компьютере — для этого нужно выполнить команду docker pull <imagename>. 

########################### POSTGRES ################################################
Переменные окружения нужно указать при запуске контейнера; СУБД PostgreSQL при запуске будет ожидать переменные с определёнными названиями:
POSTGRES_USER — имя пользователя,
POSTGRES_PASSWORD — пароль пользователя,
POSTGRES_DB — имя базы данных.

POSTGRES_USER — имя пользователя БД (необязательная переменная, значение по умолчанию — postgres);
POSTGRES_PASSWORD — пароль пользователя БД (обязательная переменная для создания БД в контейнере);
POSTGRES_DB — название базы данных (необязательная переменная, по умолчанию совпадает с POSTGRES_USER).

Переменные окружения можно передать при запуске контейнера, в параметрах команды docker run:

docker run -e POSTGRES_PASSWORD=SecretPassword -e POSTGRES_USER=PostgresUser postgres:13.10

Есть другой вариант: сохранить значения переменных в файл .env — и в параметрах команды docker run передать название этого файла. 

# Старт контейнера с именем db, переменные окружения в .env, 
# контейнер запустить из образа postgres:13.10
# Эта команда – для демонстрации, запускать ее не надо
docker run --name db --env-file .env postgres:13.10

Docker volume для контейнера PostgreSQL
Чтобы при удалении контейнера не потерять информацию, содержащуюся в базе данных, эту информацию следует хранить вне контейнера, в Docker volume на хосте.
Создайте volume для хранения данных PostgreSQL:

docker volume create pg_data 
В образе PostgreSQL все данные хранятся в директории /var/lib/postgresql/data. Именно эту директорию нужно «перенаправить» на volume за пределами контейнера:

# Старт контейнера ... связать volume pg_data 
# c папкой в контейнере /var/lib/postgresql/data
# Эта команда – для демонстрации, запускать ее не надо.
docker run ... -v pg_data:/var/lib/postgresql/dat

Адрес директории с данными не обязательно заучивать наизусть — он указан в README образа postgres.
https://github.com/docker-library/docs/blob/master/postgres/README.md#pgdata

Запускаем PostgreSQL в контейнере
Всё готово, можно запускать контейнер. В итоге команда для запуска будет такой:

# Символ \ в конце строки указывает терминалу, что команда
# продолжится на следующей строке
docker run --name db --env-file .env -v pg_data:/var/lib/postgresql/data postgres:13.10
# Запустить контейнер с именем db, 
# передать в контейнер переменные окружения из файла .env, 
# подключить Docker volume с названием pg_data,
# контейнер создать из образа postgres с тегом 13.10 


В образе PostgreSQL есть консольный клиент psql, который позволяет отправлять SQL-запросы к базе данных из командной строки.
Запустите его в отдельном терминале:

docker exec -it db psql -U django_user -d django 
exec — выполнить команду в запущенном контейнере;
-it — запуск в интерактивном режиме;
db — имя контейнера, в котором нужно выполнить команду;
psql — имя утилиты, которую нужно запустить в контейнере;
-U django_user — пользователь, от имени которого psql подключится к базе данных;
-d django — имя базы данных, к которой нужно подключиться.

При подключении к базе через psql не нужно указывать пароль пользователя django_user: 
по умолчанию PostgreSQL доверяет подключениям с того же компьютера, на котором запущен сервер.
А в нашем примере мы подключаемся к PostgreSQL из консоли psql, запущенной в том же контейнере (с точки зрения PostgreSQL — на том же компьютере).
psql поддерживает не только SQL-команды, но и специальные команды PostgreSQL. Они начинаются с обратного слеша (\).
Команды https://www.postgresql.org/docs/current/app-psql.html#APP-PSQL-META-COMMANDS

Для работы с PostgreSQL в Django используется библиотека psycopg2-binary. Если её не установить, бэкенд postgresql не заработает.
Добавьте в файл requirements.txt новый пакет psycopg2. Набор пакетов в requirements.txt должен выглядеть так:
psycopg2-binary==2.9.3 

Создадим сеть с именем django-network:

docker network create django-network 
Подключим к сети контейнеры бэкенда и базы данных.
Контейнер db уже запущен, его можно сразу подключить к докер-сети. Выполните команду:

# Присоединить к сети django-network контейнер db.
docker network connect django-network db 

Контейнер с бэкендом пока не запущен, подключим его к сети прямо при старте. Имя сети, к которой должен подключиться контейнер, указывается как параметр ключа --net.
docker run --env-file .env --net django-network --name taski_backend_container -p 8000:8000 taski_backend


Теперь, когда оба контейнера запущены и объединены в сеть, можно применить миграции Django. Откройте новое окно терминала и запустите команду выполнения миграций в контейнере бэкенда:
docker exec taski_backend_container python manage.py migrate


############################## NGINX #######################################################

Dockerfile для образа nginx будет очень коротким: 
В качестве базового слоя взять с Docker Hub готовый образ nginx:1.22.1.
Скопировать в создаваемый образ конфиг-файл nginx.conf.
Сервер Nginx ожидает найти файл с настройками по адресу /etc/nginx/templates/default.conf.template, вот туда его и скопируем из директории gateway/.

FROM nginx:1.22.1
COPY nginx.conf /etc/nginx/templates/default.conf.template 
Именно так в документации и рекомендовано добавлять файл конфигурации в образ nginx.

Когда Nginx из своего контейнера обращается к другому контейнеру, он использует имя контейнера в качестве доменного имени. 
Так, к контейнеру backend Nginx обращается по адресу http://backend:8000. 
Из-за этого Django-проект будет считать, что запрос отправлен не на http://localhost:8000, 
как указано в адресной строке браузера, а на http://backend:8000. 
Это может привести к неправильному формированию ссылок. 
Чтобы избежать этой проблемы, добавь инструкцию замены заголовка Host в nginx.conf.


подключение volume backend: # Имя и описание контейнера с бэкендом

    backend: # Имя и описание контейнера с бэкендом
    env_file: .env
    build: ./backend/  # Из какого Dockerfile собирать образ для этого контейнера:
    volumes:
      - static:/backend_static
    depends_on: # Какие контейнеры нужно запустить до старта этого контейнера:
      db: 
        condition: service_healthy  # проверка здоровья контейнера с БД
  
  frontend: # Имя третьего контейнера. Это контейнер с фронтендом
    env_file: .env
    build: ./frontend/

  gateway:
    # Сбилдить и запустить образ, 
    # описанный в Dockerfile в папке gateway
    build: ./gateway/
    # Ключ ports устанавливает
    # перенаправление всех запросов с порта 8000 хоста
    # на порт 80 контейнера
    ports:
      - 8000:80 
    volumes:
      - static:/staticfiles
    
Перезапустите Docker Compose:

# Требуется пересборка контейнеров, так как settings.py был изменён
docker compose stop && docker compose up --build 
При старте сети к контейнерам backend и gateway подключился volume static. 
Выполните команду сборки статики. После этого выполните команду копирования собранных файлов в /backend_static/static/ — перенесите файлы не в /backend_static/, а во вложенную папку: так адреса файлов для Nginx совпадут с адресами статических файлов, которые ожидает Django-проект.

# Собрать статику Django
docker compose exec backend python manage.py collectstatic
# Статика приложения в контейнере backend 
# будет собрана в директорию /app/collected_static/.

# Теперь из этой директории копируем статику в /backend_static/static/;
# эта статика попадёт на volume static в папку /static/:
docker compose exec backend cp -r /app/collected_static/. /backend_static/static/ 
Откройте в браузере страницу http://localhost:8000/admin/ и проверьте, что страница входа в админку отображается как следует:


Статика фронтенда
При запуске контейнера frontend в нём выполняется инструкция CMD, в которой описан запуск встроенного сервера, раздающего статику. Но теперь статикой займётся Nginx, так что запускать сервер фронтенда не требуется. 
Всё, что теперь нужно от контейнера frontend, — это просто собрать свои файлы статики. Текущая инструкция CMD в докерфайле фронтенда уже не нужна, и её можно заменить на команду копирования статики в директорию /frontend_static/.
Для переопределения инструкции CMD не обязательно изменять докерфайл и пересобирать образ: в docker-compose.yml в описании контейнера можно применить ключ command.
command — аналог инструкции CMD в докерфайле: здесь пишется команда, которая должна быть выполнена после запуска контейнера. Команда, указанная под ключом command, переопределяет инструкцию CMD в докерфайле, заменяет её.
Таким образом, в docker-compose.yml в описание контейнера frontend нужно внести пару изменений:
объявить связь директории /frontend_static/ c volume static (при этом директория будет создана автоматически);
добавить ключ command и выполнить команду копирования файлов: cp -r /app/build/. /frontend_static/.